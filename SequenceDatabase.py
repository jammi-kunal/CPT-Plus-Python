# -*- coding: utf-8 -*-
"""SequenceDatabase.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19hv44D5rK8WIRHC8_PNkbWH_LeYyPjmD
"""


import numpy as np
import pandas as pd
from csv import reader
import math

class SequenceDatabase():
  data= []
  target= []
  
  def __init__(self):
    data= []
    target= []

  def loadFileCustomFormat(self,trainer_data,model_data,maxCount,minSize,maxSize):
    train= []
    predata= []
    count=0
    train= pd.read_csv(trainer_data)
    for index,rows in train.iterrows():
      if rows.values is not -1:
        self.data.append(rows.values)
    if model_data is not None:
      predata= pd.read_csv(model_data)
      for index,row in predata.iterrows():
        self.data.append(row.values)
        self.target.append(list(row.values))
      return self.data,self.target
    return self.data,None

  def getSequences(self):
    return self.data

  def getModel(self):
    return self.target

  def getStats(self,name):
    print("-------------------------",name,"--------------------------")
    print("Number of Sequences: \t\t",len(self.data))
    maxItem=0
    sizes= []
    items= []
    differentItems=[]
    appearXtime= []
    count=0
    for seq in self.data:
      sizes.append(len(seq))
      mapInt= {}
      for item in seq:
        count= mapInt.get(item)
        if count is None:
          count=0
        count= count+1
        mapInt[item]= count
        items.append(item)
        if item> maxItem:
          maxItem= item
      differentItems.append(len(mapInt))
      for entry in mapInt:
        appearXtime.append(entry)
    print("Number of distinct items: \t",len(items))
    print("Largest item id: \t\t",maxItem)
    print("Itemsets per sequence: \t\t",self.calculateMean(sizes))
    print("Distinct item per sequence: \t",self.calculateMean(differentItems))
    print("Occurences of each item: \t",math.ceil(self.calculateMean(appearXtime)))
    print("Size of dataset in MB: \t\t",((len(self.data)*4)+(len(self.data)*self.calculateMean(sizes)*4)/(1000*1000)))
    print("\n")

  def calculateMean(self,listr):
    listr= self.replaceNan(listr)
    sum=0
    for val in listr:
      sum+= val
    return sum/len(listr)
    
  def replaceNan(self,listr):
    for i in range(len(listr)):
      if np.isnan(listr[i]):
        listr[i]= 0
    return listr